any "any"
check "check"
construct "construct"
constructor "constructor"
exists "exists"
export "export"
exports "exports"
expose "expose"
false "false"
forall "forall"
from "from"
given "given"
impl "impl"
implements "implements"
implies "implies"
import "import"
imports "imports"
in "in"
include "include"
includes "includes"
inject "inject"
lambda "lambda"
module "module"
new "new"
nil "nil"
null "null"
pi "pi"
preserve "preserve"
private "private"
provide "provide"
public "public"
publish "publish"
read "read"
require "require"
requires "requires"
sigma "sigma"
such "such"
suchthat "suchthat"
that "that"
true "true"
undefined "undefined"
unit "unit"
use "use"
void "void"
where "where"
with "with"
write "write"

[0-9]+\.[0-9]+ "FloatingLit"
[0-9]+ "IntegerLit"
#[A-Fa-f]* "ColorLit"
[a-zA-Z][_a-zA-Z0-9]* "Ident"
\$[a-zA-Z][_a-zA-Z0-9] "Atom"

\' "Quote"
\" "DoubleQuote"

/\* "MultiCommentOpen"
\*/ "MultiCommentClose"
// "Comment"

\( "OpenParen"
\) "CloseParen"
\{ "OpenCurly"
\} "CloseCurly"
\[ "OpenBracket"
\] "CloseBracket"

, "Comma"

== "Eqs"
!= "NotEqs"
\< "Lt"
> "Gt"
\<= "LtEqs"
>= "GtEqs"

\+= "AddAssign"
-= "SubAssign"
/= "DivAssign"
\*= "MulAssign"
&= "AndAssign"
|= "BitOrAssign"
^= "BitXorAssign"
&&= "LogicalAndAssign"
||= "LogicalOrAssign"
%= "ModuloAssign"
= "Assign"

! "LogicalNot"
#! "Shebang"
# "Hash"
% "Modulo"
& "And"
&& "LogicalAnd"
\* "Mul"
\*\* "Exp"
\+ "Add"
- "Sub"
-> "Arrow"
\. "Dot"
\.\. "Range"
\.\.\. "Spread"
/ "Div"
: "HasType"
\; "Sequence"
\<< "LeftShift"
\<\| "LeftPipe"
=> "DoubleArrow"
>> "RightShift"
\? "Try"
@ "GetAddress"
^ "BitXor"
\| "BitOr"
\|> "RightPipe"
\|\| "LogicalOr"
~ "BitNot"

λ "Lambda"
Π "Pi"
Σ "Sigma"
∀ "Forall"
∃ "Exists"

. "Unknown"
